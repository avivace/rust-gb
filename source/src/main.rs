#![no_std]
#![no_main]
#![allow(dead_code)]
#![feature(asm_experimental_arch)]
#![feature(panic_info_message)]
#![feature(strict_provenance)]
#![feature(associated_type_defaults)]

use gbdk::gb::gb::delay;
use rom_bank::{BankProvider, Banks, RomBank, RomBankMap, RomRef};

mod gbdk;
mod memory;
mod rom_bank;

// Prevents function optimization
extern "C" {
    #[link_name="test_function"]
    pub fn test_function(array: *const u8) -> u8;
}

///// Bank 1 /////
// Bank with no static value
pub struct SomeRomBank {}

impl RomBank for SomeRomBank {
    fn create_bank() -> Self {
        SomeRomBank {}
    }
}

impl SomeRomBank {
    // Each function in RomBank mustn't be inlined.
    #[inline(never)]
    pub fn some_bank1_function(&self) {
        unsafe {delay(100)};
    }
}

///// Bank 2 /////
// Bank with some static values
pub struct OtherRomBank<'a> {
    // All field's type of RomBank struct must be `RomRef`
    //
    // We can't force the Rust compiler to check this, but if you don't, you'll get 
    // a C compilation error or banking won't work properly.
    big_data: RomRef<'a, [u8;512]>,
}

// The static value in switching ROM must specify which struct use this value through
// `export_name` macro.
#[export_name="OtherRomBank BIG_DATA"]
static BIG_DATA: [u8;512] = [
    0x07,0x07,0x18,0x1F,0x32,0x2D,0x71,0x4E,0x70,0x4F,0xF8,0x87,0xF8,0x87,0xF8,0x87,
    0xFC,0x83,0xFE,0x81,0x7F,0x40,0x7F,0x40,0x3F,0x20,0x1F,0x18,0x07,0x07,0x00,0x00,
    0xC0,0xC0,0xF0,0x30,0x78,0x88,0x3C,0xC4,0x5C,0xA4,0x9E,0x62,0x3E,0xC2,0x3E,0xC2,
    0x5E,0xA2,0x7E,0x82,0x0C,0xF4,0x0C,0xF4,0x98,0x68,0xB0,0x70,0xC0,0xC0,0x00,0x00,
    0x07,0x07,0x1F,0x18,0x2F,0x30,0x4F,0x70,0x6F,0x50,0x9F,0xE0,0x9F,0xE0,0xBF,0xC0,
    0xFF,0x80,0xB7,0xC8,0x63,0x5C,0x43,0x7C,0x3F,0x20,0x1F,0x18,0x07,0x07,0x00,0x00,
    0xC0,0xC0,0xB0,0x70,0x18,0xE8,0x0C,0xF4,0x0C,0xF4,0x82,0x7E,0x82,0x7E,0x86,0x7A,
    0xC6,0x3A,0xE6,0x1A,0xF4,0x0C,0xFC,0x04,0xF8,0x08,0xF0,0x30,0xC0,0xC0,0x00,0x00,

    0x07,0x07,0x1E,0x19,0x20,0x3F,0x40,0x7F,0x42,0x7D,0x81,0xFE,0x81,0xFE,0x83,0xFC,
    0xD7,0xA8,0xBB,0xC4,0x6E,0x51,0x7C,0x43,0x3F,0x20,0x1F,0x18,0x07,0x07,0x00,0x00,
    0xC0,0xC0,0x70,0xB0,0xE8,0x18,0xF4,0x0C,0xF4,0x0C,0xFE,0x02,0xFE,0x02,0xFE,0x02,
    0xFE,0x02,0x7E,0x82,0x3C,0xC4,0x3C,0xC4,0xF8,0x08,0xF0,0x30,0xC0,0xC0,0x00,0x00,
    0x07,0x07,0x1B,0x1C,0x20,0x3F,0x40,0x7F,0x40,0x7F,0xE0,0x9F,0x90,0xEF,0x89,0xF6,
    0x8D,0xF2,0x9F,0xE0,0x5E,0x61,0x6F,0x50,0x3F,0x20,0x1F,0x18,0x07,0x07,0x00,0x00,
    0xC0,0xC0,0xB0,0x70,0x28,0xD8,0x04,0xFC,0x2C,0xD4,0x1E,0xE2,0x1E,0xE2,0x3E,0xC2,
    0x7E,0x82,0xB6,0x4A,0xE4,0x1C,0xC4,0x3C,0xF8,0x08,0xF0,0x30,0xC0,0xC0,0x00,0x00,

    0x07,0x07,0x18,0x1F,0x20,0x3F,0x40,0x7F,0x40,0x7F,0xEE,0x91,0xF1,0x8E,0xE0,0x9F,
    0xE0,0x9F,0xF1,0x8E,0x71,0x4E,0x72,0x4D,0x3F,0x20,0x1F,0x18,0x07,0x07,0x00,0x00,
    0xC0,0xC0,0xF0,0x30,0x08,0xF8,0x04,0xFC,0x04,0xFC,0x02,0xFE,0x02,0xFE,0x92,0x6E,
    0xD6,0x2A,0xFE,0x02,0xEC,0x14,0xFC,0x04,0xF8,0x08,0xF0,0x30,0xC0,0xC0,0x00,0x00,
    0x07,0x07,0x1D,0x1A,0x36,0x29,0x5C,0x63,0x6C,0x53,0xCE,0xB1,0x9F,0xE0,0x9E,0xE1,
    0xAE,0xD1,0xBF,0xC0,0x47,0x78,0x47,0x78,0x2F,0x30,0x1F,0x18,0x07,0x07,0x00,0x00,
    0xC0,0xC0,0x70,0xB0,0x08,0xF8,0x04,0xFC,0x04,0xFC,0xE2,0x1E,0x32,0xCE,0x0E,0xF2,
    0x0E,0xF2,0x1E,0xE2,0x1C,0xE4,0x2C,0xD4,0xF8,0x08,0xF0,0x30,0xC0,0xC0,0x00,0x00,

    0x07,0x07,0x1E,0x19,0x20,0x3F,0x40,0x7F,0x42,0x7D,0x81,0xFE,0x81,0xFE,0x83,0xFC,
    0xD7,0xA8,0xBB,0xC4,0x6E,0x51,0x7C,0x43,0x3F,0x20,0x1F,0x18,0x07,0x07,0x00,0x00,
    0xC0,0xC0,0x70,0xB0,0xE8,0x18,0xF4,0x0C,0xF4,0x0C,0xFE,0x02,0xFE,0x02,0xFE,0x02,
    0xFE,0x02,0x7E,0x82,0x3C,0xC4,0x3C,0xC4,0xF8,0x08,0xF0,0x30,0xC0,0xC0,0x00,0x00,
    0x07,0x07,0x1B,0x1C,0x20,0x3F,0x40,0x7F,0x40,0x7F,0xE0,0x9F,0x90,0xEF,0x89,0xF6,
    0x8D,0xF2,0x9F,0xE0,0x5E,0x61,0x6F,0x50,0x3F,0x20,0x1F,0x18,0x07,0x07,0x00,0x00,
    0xC0,0xC0,0xB0,0x70,0x28,0xD8,0x04,0xFC,0x2C,0xD4,0x1E,0xE2,0x1E,0xE2,0x3E,0xC2,
    0x7E,0x82,0xB6,0x4A,0xE4,0x1C,0xC4,0x3C,0xF8,0x08,0xF0,0x30,0xC0,0xC0,0x00,0x00,
];

impl RomBank for OtherRomBank<'_> {
    fn create_bank() -> Self {
        OtherRomBank { 
            big_data: RomRef::new(&BIG_DATA),
        }
    }
}

impl OtherRomBank<'_> {
    #[inline(never)]
    pub fn some_bank2_function(&self) {
        unsafe {delay(200)};
    }
    #[inline(never)]
    pub fn other_bank2_function(&self) {
        Self::inner_bank2_function();
        unsafe {test_function(self.big_data.fetch() as *const u8)};
        unsafe {delay(300)};
    }

    #[inline(never)]
    fn inner_bank2_function() {
        unsafe {delay(50)};
    }
}

/// rust-gb parses this part to split the Rust code into several C files for banking.
/// In other words, do not obscure this area with type aliases, etc.
impl<'a> BankProvider for Banks<'a> {
    type Bank1 = SomeRomBank;
    type Bank2 = OtherRomBank<'a>;
}

#[no_mangle]
pub extern fn main() {
    let mut rom_bank: RomBankMap<Banks> = unsafe {RomBankMap::<Banks>::new()};

    // Switch to Bank 1
    let bank1 = rom_bank.switch_to_bank1();
    bank1.some_bank1_function();

    // Switch to Bank 2
    let bank2 = rom_bank.switch_to_bank2();
    bank2.some_bank2_function();
    bank2.other_bank2_function();

    let bank2_ref = bank2.big_data.fetch();
    unsafe {test_function(bank2_ref.as_ptr() as *const u8)};
    
    // Switch to Bank 1
    let bank1: &SomeRomBank = rom_bank.switch_to_bank1();
    bank1.some_bank1_function();

    // This is not invalid because of the lifetime
    // bank2.some_bank2_function();

    // This is not invalid too
    // unsafe {test_function(bank2_ref.as_ptr() as *const u8)};
}

#[allow(unconditional_recursion)]
#[panic_handler]
#[cfg(not(test))]
fn panic_handler_phony(info: &core::panic::PanicInfo) -> ! {
    loop {}
}
